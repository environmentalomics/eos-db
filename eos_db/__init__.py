""" EOS-DB Init Module.

Contains routing for EOS-DB API, and callbacks for response modification."""

from pyramid.config import Configurator
from pyramid.events import NewRequest, NewResponse

import logging
import sys, os

from eos_db import server
from eos_db.auth import HybridAuthenticationPolicy, add_cookie_callback
from pyramid.httpexceptions import HTTPUnauthorized

log = logging.getLogger(__name__)

def add_cors_callback(event):
    """ Add response header to enable Cross-Origin Resource Sharing.  This
    should only be needed for testing, where the server is running on localhost.
    The calling domain is checked to see if it is local, and if it
    matches, then a set of allow headers are sent, allowing the origin, the
    set of methods, and the passing of credentials, which is essential for
    the pass-through token auth which we use for security. """

    def cors_headers(request, response):
        """ Callback for CORS. """

        origin = request.headers.get('Origin', 'UNKNOWN')
        log.debug("Sending CORS for origin: " + origin)
        if(origin.startswith('http://localhost:') or
           origin.startswith('http://127.0.0.1:') ):
            log.debug('Access Allowed')
            response.headers['Access-Control-Allow-Origin'] = origin
            response.headers['Access-Control-Allow-Methods'] = \
                'GET, POST, PUT, OPTIONS, DELETE, PATCH'
            response.headers['Access-Control-Allow-Headers'] = 'auth_tkt'
            response.headers['Access-Control-Allow-Credentials'] = 'false'

    event.request.add_response_callback(cors_headers)

def get_secret(settings, secret):
    """ Given the global settings and a name of a secret, determine the secret.
        The secrets we need to function are the 'authtkt' secret which does not need
        to be shared but does need to be stable, and the 'agent' secret which needs
        to be shared with the agents.
        On the production system these must be securely generated at startup.
        On the test system we can use placeholder values, but in either case there
        is no need for hard-coding them into the script here.

        :params
        :settings dict: settings
        :secret string: name of secret
    """
    #Setting a secretfile in the environment trumps any settings, or
    #else look for a secretfile in the settings.
    secretfile = ( os.environ.get(secret + "_secretfile") or
                   settings.get(secret + ".secretfile") )

    res = None
    if secretfile:
        #If you specify one the file must exist, or an exception will be raised,
        #but there is no check on the actual file contents.
        log.debug("Getting secret from " + secretfile)
        with open(secretfile) as ssfile:
            res = ssfile.read().rstrip('\n')
    else:
        #If a secret is supplied directly, use it.
        res = settings.get(secret + ".secret")
        if res and 'unittest' not in sys.modules:
            log.critical("Reading " +secret+ "secret directly from .ini file. " +
                         "This should only be used for testing.")

    if not res:
        raise ValueError("The secret cannot be empty.")
    return res


#FIXME? main takes global_config as an argument here but why?
def main(global_config, **settings):
    """ Set routes, authentication policies, and add callbacks to modify
    responses."""

    agent_spec = [ ('agent', get_secret(settings, 'agent'), 'agents') ]

    hap = HybridAuthenticationPolicy(hardcoded=agent_spec,
                                     secret=get_secret(settings, "authtkt"),
                                     realm="eos_db")

    config = Configurator(settings=settings,
                          authentication_policy=hap,
                          root_factory='eos_db.views.PermissionsMap')

    config.add_subscriber(add_cors_callback, NewRequest)
    config.add_subscriber(add_cookie_callback, NewRequest)

    # Needed to ensure proper 401 responses
    config.add_forbidden_view(hap.get_forbidden_view)

    # Do this if you need extra info generated by the Configurator, but
    # we do not.
    #settings = config.registry.settings

    # Load the default configuration file, based on the .ini file name
    # And hey, I found a use for global_config!
    settings_json = global_config['__file__'][:-4] + ".settings.json"
    if os.path.isfile(settings_json):
        server.load_config_json(settings_json)

    # Set the engine, but only if it's not already set.  This is useful
    # for testing where we can re-initialise the webapp while leaving the
    # database in place.
    server.choose_engine(settings['server'], replace=False)

    # Endpoints that can be called without authentication
    # Top-level home page. Yields API call list.
    config.add_route('home', '/')
    # View of BoostLevels from settings.py
    config.add_route('boostlevels', '/boostlevels')

    # User-related API calls (callable by users)

    config.add_route('users',       '/users')         # Return user list

    config.add_route('my_user',     '/user')          # Return info about me (including credit)
    config.add_route('my_password', '/user/password') # Set my password (only for admins or self)
    config.add_route('my_touches',  '/user/touches')  # Get server touches

    # User-related API calls (callable by Actors/Admins)
    config.add_route('user',  '/users/{name}')   # Get user details or
                                                 # Put new user or
                                                 # Delete user


    config.add_route('user_touches',  '/users/{name}/touches')
                                            # Get server touches

    config.add_route('user_password', '/users/{name}/password')
                                            # Put new password
                                            # Get password verification by posting
                                            # password=asdf ??  Or not?

    config.add_route('user_credit',   '/users/{name}/credit')
                                            # Put new credit or debit
                                            # Get current balance

    # Server-related API calls

    config.add_route('servers', '/servers')  # Return server list
    config.add_route('server',  '/servers/{name}')  # Get server details or
                                                    # Post new server or
                                                    # Delete server

    #This is used by the agents.  Can help to be absolutely sure you are talking
    #about the right server.
    config.add_route('server_by_id', '/servers/by_id/{id}')

    # Server state-related calls.
    config.add_route('states', '/states')  # Get summary count of servers in each state
    config.add_route('state',  '/states/{name}') # Get list of servers in
                                                 # the given state.
    config.add_route('deboosts', '/deboost_jobs') # Get list of servers wanting deboost

    #Define PUT calls to put the server into various states.  Each call is backed
    #by a separate function in views.py, and mostly these just add a touch, but
    #they may implement custom functionality, for example to check and deduct
    #credit when boosting, or to limit who can change to certain states.
    for state in server.get_state_list():
        config.add_route('server_' + state,         '/servers/{name}/' + state)
        config.add_route('server_by_id_' + state,   '/servers/by_id/{id}/' + state)

    #Call to state, owner, touches and get/set specification.
    for action in ('specification', 'state', 'owner', 'touches'):
        config.add_route('server_' + action      , '/servers/{name}/' + action    )
        config.add_route('server_by_id_' + action, '/servers/by_id/{id}/' + action)

    # Call the extend boost which does not correspond to any state change
    for action in ('extend_boost',):
        config.add_route('server_' + action      , '/servers/{name}/' + action    )
        config.add_route('server_by_id_' + action, '/servers/by_id/{id}/' + action)

    config.scan()
    return config.make_wsgi_app()
